# CardUI 使用指南


## 依赖

CardUI系统需要代码部分`cardUI.py`, 素材部分`imgs/*`, 库`PIL`(通常安装pillow), `tkinter`(通常在系统层面安装)。

## 环境检测

验证该系统是否正常工作，可以将`cardUI.py`, `imgs/*`放在同一路径下，新建`main.py`:

```python
from cardUI import display, start, game

pass
```

此时应当出现窗口，在终端输入空格可以关闭窗口，证明基本功能正常。

## 函数调用规则

正如上述事例表明，`cardUI`提供了`display`, `start`, `game`三个函数作为接口。

### `display`

该函数应当接受两个参数，第一个为展示的位置，第二个为要展示的列表。

请注意：

1. 位置可以接受的值是`1, 2, 3, 4`，分别对应左上，右上，左下，右下四个方位。

2. 第二个参数，即列表，应当输入一个`list[int]`类型或`list[list[int]]`。

3. 每次调用该函数，会清空所选择位置的当前所有牌。

也就是说，以下代码将会有如下表现：

```python
display(1, [3, 5, 7])
# 此时左上角出现红桃3，红桃5，红桃7三张牌
display(4, [2, 5, 9])
# 此时左上角保留红桃3，红桃5，红桃7三张牌
# 右下角出现红桃2，红桃5，红桃9三张牌
display(1, [2, 2, 2, 2])
# 此时左上角的三张牌被替换为四张红桃2
# 右下角的红桃2，红桃5，红桃9三张牌得以保留
display(4, [])
# 此时左上角的四张红桃2依然保留
# 右下角清空
```

## `start`

除非关闭窗口，否则该函数不会返回。

```python
start(new_card, sort_card=None, search_card=None, target_card=None)
```

一个必要参数`new_card`：发牌，该参数是一个函数，返回一个由一张或多张卡牌组成的列表。在点击发牌按钮时会被调用。

第一个可选参数`sort_card`：排序，该参数是一个函数，接收一个卡牌列表（一般由`new_card`返回），应当返回一个排过序的卡牌列表。这里的排序规则可以自由修改，同学们可以自己给自己提升难度。

第二个可选参数`search_card`：搜索，该参数是一个函数，接收一个表示当前牌型的卡牌列表（一般由`new_card`或者`sort_card`返回）和一个表示搜索牌型的卡牌列表。应当返回一个包含牌型的列表。注意：我们认为`[[2, 2]]`，`[[2, 2], [3, 1]]`为牌型，而`[[[2, 2]]]`，`[[[2, 2]], [[3, 1], [4, 2]]]`为包含牌型的列表。

第三个可选参数`targe_card`：搜索的目标，应当是包含卡牌的列表。如果提供了该参数，他会以卡牌的形式显示在右上方，并且当点击搜索时，会以第二个参数传入`search_card`。

## `game`

```python
game(new_card, your, opponent=None):
```

与该函数相关的所有实现**必须**考虑花色。

第一个必要参数`new_card`：发牌，该参数是一个函数，返回一个由两套牌型组成的列表。两套牌型中，以及相互之间都不应该存在相同的牌。（我们在正常的棋牌游戏中通常也不会出现相同的吧）

第二个必要参数`your`：己方的出牌策略，该参数是一个函数，应当接受三个参数：目前自己的手牌，对方的手牌（没错，在我们的游戏中你可以看到对方的牌），当前场上的牌。该函数应当返回你期望在本轮中打出的牌。（不出可以是`None`）

一个可选参数`opponent`：对方的出牌策略，该参数是一个函数，规则与`your`完全相同，是对方将要使用的策略。该参数如果留空（或者填写`None`）将会复制一份己方策略。

## 其他

### 怎么表示一张牌呢？

不带花色：数字，`2`表示2，`13`表示K，`14`表示A。

带花色：列表（确切来说是`list[int]`，`int`的数量应当为2），第一个元素为点数，第二个元素为花色：我们在`cardUI.py`可以找到以下代码，说明的就是该元素和花色之间的映射关系。

```python
_COLOR = {0: "club", 1: "diamond", 2: "heart", 3: "spade"}
```

显然，点数的范围应当是`0, 1, 2, 3`。

### 为什么花色的表示这么麻烦？

作为一个（未来的）CS相关从业者，这里首要的想法一定是将卡牌进行打包，产生如下的结构：

```python
class Card:
    def __init__(self):
        self.pts = # Whatever
        self.color = # Whatever

    def __str__(self):
        return f"{self.pts}, {_COLOR[self.color]}"

    def __eq__(self, other):
        return self.pts == other.pts

    # 这里还有一堆运算符，篇幅所限不写了
```

但是由于课程容量限制，我们讲不到`class`，更别提这些乱七八糟的魔法变量和魔法函数了。所以仅供参考。
